if exists (select * from sysobjects where id = object_id(N'fx.procScriptDiagram') and xtype in (N'P'))
drop procedure fx.procScriptDiagram
GO
/*
<summary>
	Script SQL Server 2005 diagrams 
</summary>

<remarks>
	Helpful Articles
	
	1) Upload / Download to Sql 2005
	http://staceyw.spaces.live.com/blog/cns!F4A38E96E598161E!404.entry
	
	2) MSDN: Using Large-Value Data Types
	http://msdn2.microsoft.com/en-us/library/ms178158.aspx
	
	3) "original" Script, Save, Export SQL 2000 Database Diagrams
	http://www.thescripts.com/forum/thread81534.html
	http://groups-beta.google.com/group/comp.databases.ms-sqlserver/browse_frm/thread/ca9a9229d06a56f9?dq=&hl=en&lr=&ie=UTF-8&oe=UTF-8&prev=/groups%3Fdq%3D%26num%3D25%26hl%3Den%26lr%3D%26ie%3DUTF-8%26oe%3DUTF-8%26group%3Dcomp.databases.ms-sqlserver%26start%3D25
</remarks>

<author>
	Craig Dunn
	inspired by usp_ScriptDatabaseDiagrams for Sql Server 2000 by Clay Beatty
</author>

<example>
	NOTE: Scalar-valued Function fx.fnConvertVarbinaryTovarcharHex must exist before this script is run
	exec fx.procScriptDiagram 'DatabaseName'
</example>

<param name="name">Name of the diagram in the Sql Server database instance</param>
*/

create procedure fx.procScriptDiagram
(
	@name varchar(128)
)
as
begin

	set nocount on
	declare @diagram_id		int
	declare @index			int
	declare @size			int
	declare @chunk			int
	declare @line			varchar(max)
	-- set start index, and chunk 'constant' value
	set @index = 1  -- 
	set @chunk = 32	-- values that work: 2, 6
					-- values that fail: 15,16, 64
	-- Get PK diagram_id using the diagram's name (which is what the user is familiar with)
	select 
		@diagram_id=diagram_id,	
		@size = datalength(definition) 
	from sysdiagrams 
	where [name] = @name

	if @diagram_id IS null
	begin
		print '/**<error>Diagram name [' + @name + '] could not be found.</error>*/' 
	end
	else -- Diagram exists
	begin
		-- Now with the diagram_id, do all the work
		print '/**'
		print '<summary>'
		print 'Restoring diagram ''' + @name + ''''
		print '</summary>'
		print '<remarks>'
		print 'Will attempt to create [sysdiagrams] table if it doesn''t already exist'
		print '</remarks>'
		print '<generated>' + left(convert(varchar(23), getDate(), 121), 16) + '</generated>'
		print '*/'
		print 'print ''* Creating diagram ...'''
		print 'print ''   - Start restoring diagram [' + @name + '] '''
		print '	-- if the sysdiagrams table has not been created in this database, create it!
				if not exists (select * from INFORMATION_SCHEMA.TABLES where TABLE_NAME = ''sysdiagrams'')
				begin
					-- Create table script generated by Sql Server Management Studio
					-- _assume_ this is roughly equivalent to what Sql Server/Management Studio
					-- creates the first time you add a diagram to a 2005 database
					create table[dbo].[sysdiagrams](
						[name] [sysname] not null,
						[principal_id] [int] not null,
						[diagram_id] [int] identity(1,1) not null,
						[version] [int] null,
						[definition] [varbinary](max) null,
					primary key clustered
					(
						[diagram_id] asC
					)with (pad_index  = off, ignore_dup_key = off)  ,
					 constraint [UK_principal_name] unique nonclustered
					(
						[principal_id] asC,
						[name] asC
					)with (pad_index  = off, ignore_dup_key = off) 
					) 
					exec sys.sp_addextendedproperty @name=N''microsoft_database_tools_support'', @value=1 , @level0type=N''SCHEMA'',@level0name=N''dbo'', @level1type=N''TABLE'',@level1name=N''sysdiagrams''
					print ''   - Supporting diagrams is enabled for the database...''
				end
				-- Target table will now exist, if it didn''t before'
		print 'set nocount on -- Hide (1 row affected) messages'
		print 'declare @newid int'
		print 'declare @DiagramSuffix          varchar (50)'
		print ''
		print 'print ''   - Suffix diagram name with date, to ensure uniqueness...'''	
		print 'set @DiagramSuffix = '' '' + left(convert(varchar(23), getDate(), 121), 16)'
		print ''
		-- Output the insert that _creates_ the diagram record, with a non-null [definition],
		-- important because .WRITE *cannot* be called against a null value (in the WHILE loop)
		-- so we insert 0x so that .WRITE has 'something' to append to...
		print 'begin try'
		print 'print ''   - Creating diagram entity [' + @name + ']'''
		select @line =  
			  '    insert into sysdiagrams ([name], [principal_id], [version], [definition])'
			+ ' values (''' + [name] + '''+@DiagramSuffix, '+ cast (principal_id as varchar(100))+', '+CasT (version as varchar(100))+', 0x)'
		from sysdiagrams where diagram_id = @diagram_id
		print @line
		print '    set @newid = scope_identity()'
		print 'end try'
		print 'begin catch'
		print '    print ''   - Error occured: '' + Error_Message() + '' '''
		print '    print ''   - end diagram Script - fix the error before running again.'''
		print '    return'
		print 'end catch'
		print ''
		print 'print ''   - Filling diagram binary data ...'''
		print 'begin try'
		WHILE @index < @size
		begin
			-- Output as many UPDATE statements as required to append all the diagram binary
			-- data, represented as hexadecimal strings
			select @line =  
				 '    UPDATE sysdiagrams set [definition] .Write ('
				+ ' 0x' + upper(fx.fnConvertVarbinaryTovarcharHex (substring (definition, @index, @chunk)))
				+ ', null, 0) where diagram_id = @newid -- index:' + cast(@index as varchar(100))
			from	sysdiagrams 
			where	diagram_id = @diagram_id
			print @line
			set @index = @index + @chunk
		end
		print ''
		print '    print ''   - Finished writing diagram id '' + CasT(@newid as varchar(100)) + ''  '''

		print 'end try'
		print 'begin catch'
		print '    -- if we got here, the [definition] updates didn''t complete, so delete the diagram row'
		print '    -- (and hope it doesn''t fail!)'
		print '    delete from sysdiagrams where diagram_id = @newid'
		print '    print ''   - Error occured: '' + Error_Message() + '' '''
		print '    print ''	  - end diagram Script - fix the error before running again.'''
		print '    return'
		print 'end catch'
	end
end