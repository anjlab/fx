if exists (select * from sysobjects where id = object_id(N'fx.procScriptDiagram') and xtype in (N'P'))
drop procedure fx.procScriptDiagram
GO
/*
<summary>
	Script SQL Server 2005 diagrams 
</summary>

<remarks>
	Helpful Articles
	
	1) Upload / Download to Sql 2005
	http://staceyw.spaces.live.com/blog/cns!F4A38E96E598161E!404.entry
	
	2) MSDN: Using Large-Value Data Types
	http://msdn2.microsoft.com/en-us/library/ms178158.aspx
	
	3) "original" Script, Save, Export SQL 2000 Database Diagrams
	http://www.thescripts.com/forum/thread81534.html
	http://groups-beta.google.com/group/comp.databases.ms-sqlserver/browse_frm/thread/ca9a9229d06a56f9?dq=&hl=en&lr=&ie=UTF-8&oe=UTF-8&prev=/groups%3Fdq%3D%26num%3D25%26hl%3Den%26lr%3D%26ie%3DUTF-8%26oe%3DUTF-8%26group%3Dcomp.databases.ms-sqlserver%26start%3D25
</remarks>

<author>
	Craig Dunn
	inspired by usp_ScriptDatabaseDiagrams for Sql Server 2000 by Clay Beatty
</author>

<example>
	NOTE: Scalar-valued Function fx.fnConvertVarbinaryTovarcharHex must exist before this script is run
	exec fx.procScriptDiagram 'DatabaseName'
</example>

<param Name="Name">Name of the diagram in the Sql Server database instance</param>
*/

create procedure fx.procScriptDiagram
(
	@Name varchar(128),
	@Diagram varchar(max) output
)
as
begin

	set nocount on
	declare @DiagramID		int
	declare @Index			int
	declare @Size			int
	declare @Chunk			int
	declare @Line			varchar(max)
	-- set start Index, and Chunk 'constant' value
	set @Index = 1  -- 
	set @Chunk = 32	-- values that work: 2, 6
					-- values that fail: 15,16, 64
	-- Get PK DiagramID using the diagram's Name (which is what the user is familiar with)
	select 
		@DiagramID = DiagramID,	
		@Size = datalength(definition) 
	from sysdiagrams 
	where [Name] = @Name

	if @DiagramID IS null
	begin
		set @Diagram = '/**<error>Diagram Name [' + @Name + '] could not be found.</error>*/' 
	end
	else -- Diagram exists
	begin
		-- Now with the DiagramID, do all the work
		set @Diagram = 
'/*
<summary>
	Restoring diagram ''' + @Name + '''
</summary>
<remarks>
	Will attempt to create [sysdiagrams] table if it doesn''t already exist
</remarks>
<generated>' + left(convert(varchar(23), getDate(), 121), 16) + '</generated>
*/
	-- if the sysdiagrams table has not been created in this database, create it!
if not exists (select * from INFORMATION_SCHEMA.TABLES where TABLE_NAME = ''sysdiagrams'')
begin
	-- Create table script generated by Sql Server Management Studio
	-- _assume_ this is roughly equivalent to what Sql Server/Management Studio
	-- creates the first time you add a diagram to a 2005 database
	create table[dbo].[sysdiagrams](
		[Name] [sysName] not null,
		[principal_id] [int] not null,
		[DiagramID] [int] identity(1,1) not null,
		[version] [int] null,
		[definition] [varbinary](max) null,
		primary key clustered([DiagramID] asc)with (pad_Index  = off, ignore_dup_key = off)  ,
		constraint [UK_principal_Name] unique nonclustered ([principal_id] asc, [Name] asc)
	) 
	exec sys.sp_addextendedproperty @Name=N''microsoft_database_tools_support'', @value=1 , @level0type=N''SCHEMA'',@level0Name=N''dbo'', @level1type=N''TABLE'',@level1Name=N''sysdiagrams''
end
-- Target table will now exist, if it didn''t before
set nocount on
declare @newid int

	/*
		Output the insert that _creates_ the diagram record, with a non-null [definition],
		important because .WRITE *cannot* be called against a null value (in the WHILE loop)
		so we insert 0x so that .WRITE has something to append to...
	*/
	
begin try'
	select top 1 @Diagram = @Diagram + '
	insert into sysdiagrams ([Name], [principal_id], [version], [definition])
	values (''' + [Name] + cast (principal_id as varchar(100)) + ', ' + cast (version as varchar(100)) + ', 0x)' + char(13) + char(10)
	from sysdiagrams where DiagramID = @DiagramID
	set @Diagram = @Diagram + '
	set @newid = scope_identity()
end try
begin catch
	print ''   - Error occured:  + Error_Message() +  ''
    return
end catch
begin try' + char(13) + char(10)
		while @Index < @Size
		begin
			-- Output as many UPDATE statements as required to append all the diagram binary
			-- data, represented as hexadecimal strings
			select @Line =  
				 '		UPDATE sysdiagrams set [definition] .Write ('
				+ ' 0x' + upper(fx.fnConvertVarbinaryTovarcharHex (substring (definition, @Index, @Chunk)))
				+ ', null, 0) where DiagramID = @newid -- Index:' + cast(@Index as varchar(100))
				+ char(13) + char(10)
			from	sysdiagrams 
			where	DiagramID = @DiagramID
			set @Diagram = @Diagram + @Line
			set @Index = @Index + @Chunk
		end
	set @Diagram = @Diagram + '
end try
begin catch
    -- if we got here, the [definition] updates didn''t complete, so delete the diagram row
    -- (and hope it doesn''t fail!)
    delete from sysdiagrams where DiagramID = @newid
    print ''   - Error occured: '' + Error_Message() + '' ''
    return
end catch'
	end
end